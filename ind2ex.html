<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#0c0c0c">
  <title>üåå Resonance Hub ‚àû v18</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
  <style>
    body {
      background: #0c0c0c;
      color: #e0e0e0;
      font-family: 'Orbitron', sans-serif;
      padding: 50px 30px;
      max-width: 800px;
      margin: auto;
      text-align: center;
      position: relative;
      overflow-x: hidden;
    }
    #matrix {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      opacity: 0.1;
      z-index: -1;
    }
    #overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(45deg, rgba(0, 255, 255, 0.1), rgba(0, 0, 255, 0.1));
      opacity: 0.3;
      animation: pulse-overlay 4s infinite;
      z-index: -1;
    }
    #scan-lines {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: repeating-linear-gradient(transparent, transparent 4px, rgba(0, 255, 255, 0.05) 4px, rgba(0, 255, 255, 0.05) 5px);
      animation: scan 2s linear infinite;
      z-index: -1;
    }
    h1 {
      font-size: 2.2em;
      margin-bottom: 30px;
      text-shadow: 0 0 5px #0ff;
      animation: glitch 4s infinite;
    }
    canvas {
      display: block;
      margin: 20px auto;
      border: 2px solid #0ff;
      background: #000;
      animation: pulse 4s infinite, glitch 4s infinite;
    }
    button, input, select, textarea {
      background: linear-gradient(45deg, #0ff, #00f);
      color: #eee;
      padding: 12px;
      border: 2px solid #0ff;
      border-radius: 8px;
      margin: 8px;
      cursor: pointer;
      font-size: 1em;
      width: 80%;
      text-shadow: 0 0 3px #0ff;
      animation: glitch 4s infinite, neon-border 2s infinite;
      transition: all 0.2s;
    }
    button:hover, input:hover, select:hover, textarea:hover {
      transform: scale(1.1);
      box-shadow: 0 0 15px #0ff;
    }
    button:active {
      filter: brightness(1.5) drop-shadow(0 0 5px #ff0);
    }
    #controls {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 8px;
    }
    #floating-panel {
      position: fixed;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
      display: flex;
      flex-direction: column;
      gap: 8px;
      z-index: 10;
    }
    #floating-panel button {
      width: 50px;
      height: 50px;
      padding: 10px;
      font-size: 0.8em;
      border-radius: 50%;
    }
    #resonance-slider, #element-editor, #node-editor, #pattern-editor, #animation-editor, #fediverse-preview {
      width: 80%;
      margin: 15px auto;
    }
    #timeline {
      display: flex;
      overflow-x: auto;
      gap: 10px;
    }
    .timeline-item {
      background: #1a1a1a;
      padding: 10px;
      border: 2px solid #0ff;
      cursor: pointer;
      animation: glitch 4s infinite;
      transition: all 0.2s;
    }
    .timeline-item:hover {
      background: #333;
      transform: scale(1.05);
      box-shadow: 0 0 10px #0ff;
    }
    #output {
      text-align: center;
      margin-top: 20px;
      font-size: 1.2em;
      text-shadow: 0 0 3px #0ff;
      animation: glitch 4s infinite;
    }
    #harmonies {
      display: grid;
      gap: 15px;
      margin: 20px 0;
    }
    .harmony-card {
      background: #1a1a1a;
      padding: 15px;
      border: 2px solid #0ff;
      cursor: pointer;
      animation: glitch 4s infinite;
      transition: all 0.2s;
    }
    .harmony-card:hover {
      background: #333;
      transform: scale(1.05);
      box-shadow: 0 0 10px #0ff;
    }
    pre {
      background: #111;
      padding: 10px;
      overflow-x: auto;
      margin-top: 20px;
      display: none;
    }
    footer {
      margin-top: 60px;
      font-size: 0.8em;
      color: #555;
      text-shadow: 0 0 3px #0ff;
      animation: glitch 4s infinite;
    }
    @keyframes glitch {
      0% { transform: translate(0); opacity: 1; filter: hue-rotate(0deg); }
      2% { transform: translate(1px, 1px); opacity: 0.95; filter: hue-rotate(10deg); }
      4% { transform: translate(-1px, -1px); opacity: 0.95; filter: hue-rotate(-10deg); }
      6% { transform: translate(0); opacity: 1; filter: hue-rotate(0deg); }
      100% { transform: translate(0); opacity: 1; filter: hue-rotate(0deg); }
    }
    @keyframes pulse {
      0% { filter: brightness(1); }
      50% { filter: brightness(1.5); }
      100% { filter: brightness(1); }
    }
    @keyframes pulse-overlay {
      0% { opacity: 0.3; }
      50% { opacity: 0.5; }
      100% { opacity: 0.3; }
    }
    @keyframes neon-border {
      0% { border-color: #0ff; box-shadow: 0 0 5px #0ff; }
      50% { border-color: #00f; box-shadow: 0 0 10px #00f; }
      100% { border-color: #0ff; box-shadow: 0 0 5px #0ff; }
    }
    @keyframes scan {
      0% { background-position: 0 0; }
      100% { background-position: 0 100%; }
    }
  </style>
</head>
<body>
  <div id="overlay"></div>
  <div id="scan-lines"></div>
  <canvas id="matrix"></canvas>
  <h1>üåå Resonance Hub ‚àû v18</h1>
  <p>–•–≤–∏–ª—å–æ–≤–∏–π –≥–æ–ª–æ–≥—Ä–∞—Ñ—ñ—á–Ω–∏–π –≤–∏—Ö–æ—Ä ‚Äî —Ç–≤–æ—Ä–∏, —Ä–µ–∑–æ–Ω—É–π, –æ–±‚Äô—î–¥–Ω—É–π –≤—ñ—á–Ω—ñ—Å—Ç—å!</p>

  <div id="controls">
    <input type="text" id="harmonyName" placeholder="–ù–∞–∑–≤–∞ –≥–∞—Ä–º–æ–Ω—ñ—ó" title="–í–≤–µ–¥–∏ –Ω–∞–∑–≤—É –¥–ª—è –Ω–æ–≤–æ—ó –≥–∞—Ä–º–æ–Ω—ñ—ó">
    <button onclick="generateHarmonyName()" title="–ó–≥–µ–Ω–µ—Ä—É–≤–∞—Ç–∏ –≤–∏–ø–∞–¥–∫–æ–≤—É –Ω–∞–∑–≤—É –≥–∞—Ä–º–æ–Ω—ñ—ó">üé≤ –ó–≥–µ–Ω–µ—Ä—É–≤–∞—Ç–∏ –Ω–∞–∑–≤—É</button>
    <input type="number" id="entropy" placeholder="–ï–Ω—Ç—Ä–æ–ø—ñ—è (0-1)" min="0" max="1" step="0.1" title="–ó–∞–¥–∞–π —Ä—ñ–≤–µ–Ω—å —Ö–∞–æ—Å—É (0-1)">
    <input type="number" id="level" placeholder="–†—ñ–≤–µ–Ω—å (0-10)" min="0" max="10" step="1" title="–ó–∞–¥–∞–π —Ä—ñ–≤–µ–Ω—å —Ä–µ–∑–æ–Ω–∞–Ω—Å—É (0-10)">
    <input type="range" id="resonance-slider" min="0" max="100" value="60" oninput="updateResonance(this.value)" title="–ù–∞–ª–∞—à—Ç—É–π —Ä–µ–∑–æ–Ω–∞–Ω—Å (0-100%)">
    <select id="fusion" title="–í–∏–±–µ—Ä–∏ —Ç–∏–ø –≥–∞—Ä–º–æ–Ω—ñ—ó">
      <option value="ultra">–£–ª—å—Ç—Ä–∞–≥–∞—Ä–º–æ–Ω—ñ—ó</option>
      <option value="hyper">–ì—ñ–ø–µ—Ä–≥–∞—Ä–º–æ–Ω—ñ—ó</option>
      <option value="all">–£—Å–µ</option>
    </select>
    <div id="element-editor">
      <input type="text" id="elementName" placeholder="–ù–∞–∑–≤–∞ –µ–ª–µ–º–µ–Ω—Ç–∞" title="–í–≤–µ–¥–∏ –Ω–∞–∑–≤—É –Ω–æ–≤–æ–≥–æ –µ–ª–µ–º–µ–Ω—Ç–∞">
      <select id="elementType" title="–í–∏–±–µ—Ä–∏ —Ç–∏–ø –µ–ª–µ–º–µ–Ω—Ç–∞">
        <option value="glyph">–ì–ª—ñ—Ñ</option>
        <option value="network">–ú–µ—Ä–µ–∂–∞</option>
        <option value="rule">–ü—Ä–∞–≤–∏–ª–æ</option>
        <option value="cosmos">–ö–æ—Å–º–æ—Å</option>
      </select>
      <button onclick="addElement()" title="–î–æ–¥–∞—Ç–∏ –Ω–æ–≤–∏–π –µ–ª–µ–º–µ–Ω—Ç">‚ûï –î–æ–¥–∞—Ç–∏ –µ–ª–µ–º–µ–Ω—Ç</button>
    </div>
    <div id="node-editor">
      <select id="nodeFrom" title="–í–∏–±–µ—Ä–∏ –ø–æ—á–∞—Ç–∫–æ–≤–∏–π –µ–ª–µ–º–µ–Ω—Ç –¥–ª—è –∑–≤‚Äô—è–∑–∫—É">
        <option value="">–í–∏–±–µ—Ä–∏ –µ–ª–µ–º–µ–Ω—Ç (–∑)</option>
      </select>
      <select id="nodeTo" title="–í–∏–±–µ—Ä–∏ –∫—ñ–Ω—Ü–µ–≤–∏–π –µ–ª–µ–º–µ–Ω—Ç –¥–ª—è –∑–≤‚Äô—è–∑–∫—É">
        <option value="">–í–∏–±–µ—Ä–∏ –µ–ª–µ–º–µ–Ω—Ç (–¥–æ)</option>
      </select>
      <input type="number" id="nodeWeight" placeholder="–í–∞–≥–∞ –∑–≤‚Äô—è–∑–∫—É (0-1)" min="0" max="1" step="0.1" title="–ó–∞–¥–∞–π –≤–∞–≥—É –∑–≤‚Äô—è–∑–∫—É (0-1)">
      <button onclick="addNodeConnection()" title="–°—Ç–≤–æ—Ä–∏—Ç–∏ –∑–≤‚Äô—è–∑–æ–∫ –º—ñ–∂ –µ–ª–µ–º–µ–Ω—Ç–∞–º–∏">üîó –î–æ–¥–∞—Ç–∏ –∑–≤‚Äô—è–∑–æ–∫</button>
    </div>
    <div id="pattern-editor">
      <select id="patternType" title="–í–∏–±–µ—Ä–∏ —Ç–∏–ø —Ä–µ–∑–æ–Ω–∞–Ω—Å–Ω–æ–≥–æ –ø–∞—Ç–µ—Ä–Ω—É">
        <option value="sine">–°–∏–Ω—É—Å–æ—ó–¥–∞–ª—å–Ω–∏–π</option>
        <option value="exp">–ï–∫—Å–ø–æ–Ω–µ–Ω—Ü—ñ–∞–ª—å–Ω–∏–π</option>
        <option value="chaos">–•–∞–æ—Ç–∏—á–Ω–∏–π</option>
      </select>
      <input type="number" id="patternAmplitude" placeholder="–ê–º–ø–ª—ñ—Ç—É–¥–∞ (0-10)" min="0" max="10" step="1" title="–ó–∞–¥–∞–π –∞–º–ø–ª—ñ—Ç—É–¥—É –ø–∞—Ç–µ—Ä–Ω—É (0-10)">
      <button onclick="applyPattern()" title="–ó–∞—Å—Ç–æ—Å—É–≤–∞—Ç–∏ –ø–∞—Ç–µ—Ä–Ω –¥–æ –µ–ª–µ–º–µ–Ω—Ç—ñ–≤">üé® –ó–∞—Å—Ç–æ—Å—É–≤–∞—Ç–∏ –ø–∞—Ç–µ—Ä–Ω</button>
    </div>
    <div id="animation-editor">
      <select id="animationType" title="–í–∏–±–µ—Ä–∏ —Ç–∏–ø –∞–Ω—ñ–º–∞—Ü—ñ—ó">
        <option value="rotate">–û–±–µ—Ä—Ç–∞–Ω–Ω—è</option>
        <option value="scale">–ú–∞—Å—à—Ç–∞–±—É–≤–∞–Ω–Ω—è</option>
        <option value="color">–ó–º—ñ–Ω–∞ –∫–æ–ª—å–æ—Ä—É</option>
      </select>
      <input type="number" id="animationSpeed" placeholder="–®–≤–∏–¥–∫—ñ—Å—Ç—å (0-10)" min="0" max="10" step="1" title="–ó–∞–¥–∞–π —à–≤–∏–¥–∫—ñ—Å—Ç—å –∞–Ω—ñ–º–∞—Ü—ñ—ó (0-10)">
      <button onclick="applyAnimation()" title="–ó–∞—Å—Ç–æ—Å—É–≤–∞—Ç–∏ –∞–Ω—ñ–º–∞—Ü—ñ—é –¥–æ –µ–ª–µ–º–µ–Ω—Ç—ñ–≤">üé¨ –ó–∞—Å—Ç–æ—Å—É–≤–∞—Ç–∏ –∞–Ω—ñ–º–∞—Ü—ñ—é</button>
    </div>
    <button onclick="startHarmony()" title="–ó–∞–ø—É—Å—Ç–∏—Ç–∏ —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è –Ω–æ–≤–æ—ó –≥–∞—Ä–º–æ–Ω—ñ—ó">‚ñ∂Ô∏è –°—Ç–≤–æ—Ä–∏—Ç–∏ –≥–∞—Ä–º–æ–Ω—ñ—é</button>
    <button onclick="stopHarmony()" title="–ó—É–ø–∏–Ω–∏—Ç–∏ –∞–∫—Ç–∏–≤–Ω—É –≥–∞—Ä–º–æ–Ω—ñ—é">‚èπÔ∏è –ó—É–ø–∏–Ω–∏—Ç–∏</button>
    <button onclick="saveMoment()" title="–ó–±–µ—Ä–µ–≥—Ç–∏ –ø–æ—Ç–æ—á–Ω–∏–π –º–æ–º–µ–Ω—Ç –≥–∞—Ä–º–æ–Ω—ñ—ó">üìç –ó–±–µ—Ä–µ–≥—Ç–∏ –º–æ–º–µ–Ω—Ç</button>
    <button onclick="generateSingularity()" title="–°—Ç–≤–æ—Ä–∏—Ç–∏ —Å–∏–Ω–≥—É–ª—è—Ä–Ω—ñ—Å—Ç—å —ñ–∑ –¥–≤–æ—Ö –µ–ª–µ–º–µ–Ω—Ç—ñ–≤">üåë –°—Ç–≤–æ—Ä–∏—Ç–∏ —Å–∏–Ω–≥—É–ª—è—Ä–Ω—ñ—Å—Ç—å</button>
    <button onclick="generateFractal()" title="–°—Ç–≤–æ—Ä–∏—Ç–∏ —Ñ—Ä–∞–∫—Ç–∞–ª —ñ–∑ –ø–æ—Ç–æ—á–Ω–∏—Ö –µ–ª–µ–º–µ–Ω—Ç—ñ–≤">üåê –°—Ç–≤–æ—Ä–∏—Ç–∏ —Ñ—Ä–∞–∫—Ç–∞–ª</button>
    <button onclick="generateNeuralLink()" title="–°—Ç–≤–æ—Ä–∏—Ç–∏ –Ω–µ–π—Ä–æ–Ω–Ω–∏–π –∑–≤‚Äô—è–∑–æ–∫ –º—ñ–∂ –µ–ª–µ–º–µ–Ω—Ç–∞–º–∏">üß† –°—Ç–≤–æ—Ä–∏—Ç–∏ –Ω–µ–π—Ä–æ–Ω–Ω–∏–π –∑–≤‚Äô—è–∑–æ–∫</button>
    <button onclick="generatePulse()" title="–ó–∞–ø—É—Å—Ç–∏—Ç–∏ —Ä–µ–∑–æ–Ω–∞–Ω—Å–Ω–∏–π —ñ–º–ø—É–ª—å—Å">üí• –ó–∞–ø—É—Å—Ç–∏—Ç–∏ —ñ–º–ø—É–ª—å—Å</button>
    <button onclick="generateFlare()" title="–ó–∞–ø—É—Å—Ç–∏—Ç–∏ —Ä–µ–∑–æ–Ω–∞–Ω—Å–Ω–∏–π —Å–ø–∞–ª–∞—Ö">‚ú® –ó–∞–ø—É—Å—Ç–∏—Ç–∏ —Å–ø–∞–ª–∞—Ö</button>
    <button onclick="generateHologram()" title="–ó–∞–ø—É—Å—Ç–∏—Ç–∏ –≥–æ–ª–æ–≥—Ä–∞—Ñ—ñ—á–Ω–∏–π –µ—Ñ–µ–∫—Ç">üå† –ó–∞–ø—É—Å—Ç–∏—Ç–∏ –≥–æ–ª–æ–≥—Ä–∞–º—É</button>
    <button onclick="generateVortex()" title="–ó–∞–ø—É—Å—Ç–∏—Ç–∏ –≤–∏—Ö—Ä–æ–≤–∏–π —Ä—É—Ö –µ–ª–µ–º–µ–Ω—Ç—ñ–≤">üåÄ –ó–∞–ø—É—Å—Ç–∏—Ç–∏ –≤–∏—Ö–æ—Ä</button>
    <button onclick="generateRipple()" title="–ó–∞–ø—É—Å—Ç–∏—Ç–∏ —Ö–≤–∏–ª—ñ, —â–æ —Ä–æ–∑—Ö–æ–¥—è—Ç—å—Å—è –≤—ñ–¥ –µ–ª–µ–º–µ–Ω—Ç—ñ–≤">üí´ –ó–∞–ø—É—Å—Ç–∏—Ç–∏ –ø—É–ª—å—Å–∞—Ü—ñ—é</button>
    <button onclick="generateWave()" title="–ó–∞–ø—É—Å—Ç–∏—Ç–∏ —Ä–µ–∑–æ–Ω–∞–Ω—Å–Ω—É —Ö–≤–∏–ª—é –≤—ñ–¥ —è–¥—Ä–∞">üåä –ó–∞–ø—É—Å—Ç–∏—Ç–∏ —Ö–≤–∏–ª—é</button>
    <button onclick="generateLinePulse()" title="–ó–∞–ø—É—Å—Ç–∏—Ç–∏ –ø—É–ª—å—Å–∞—Ü—ñ—é –ª—ñ–Ω—ñ–π –∑–≤‚Äô—è–∑–∫—ñ–≤">üåå –ü—É–ª—å—Å–∞—Ü—ñ—è –ª—ñ–Ω—ñ–π</button>
    <button onclick="showPostHistory()" title="–ü–æ–∫–∞–∑–∞—Ç–∏ —ñ—Å—Ç–æ—Ä—ñ—é –ø–æ—Å—Ç—ñ–≤ —É Fediverse">üìú –Ü—Å—Ç–æ—Ä—ñ—è –ø–æ—Å—Ç—ñ–≤</button>
    <select id="fediverse-instance" title="–í–∏–±–µ—Ä–∏ —ñ–Ω—Å—Ç–∞–Ω—Å Fediverse –¥–ª—è –ø—É–±–ª—ñ–∫–∞—Ü—ñ—ó">
      <option value="mastodon.social">mastodon.social</option>
      <option value="pleroma.instance">pleroma.instance</option>
    </select>
    <textarea id="fediverse-post" placeholder="–ö–∞—Å—Ç–æ–º–Ω–∏–π –ø–æ—Å—Ç –¥–ª—è Fediverse" title="–í–≤–µ–¥–∏ —Ç–µ–∫—Å—Ç –¥–ª—è –ø—É–±–ª—ñ–∫–∞—Ü—ñ—ó –≤ Fediverse"></textarea>
    <input type="datetime-local" id="fediverse-schedule" placeholder="–ó–∞–ø–ª–∞–Ω—É–≤–∞—Ç–∏ –ø–æ—Å—Ç" title="–ó–∞–¥–∞–π —á–∞—Å –¥–ª—è –∑–∞–ø–ª–∞–Ω–æ–≤–∞–Ω–æ—ó –ø—É–±–ª—ñ–∫–∞—Ü—ñ—ó">
    <div id="fediverse-preview"></div>
    <button onclick="postToFediverse()" title="–û–ø—É–±–ª—ñ–∫—É–≤–∞—Ç–∏ –≤ Fediverse">üì° –ü–æ–¥—ñ–ª–∏—Ç–∏—Å—è –≤ Fediverse</button>
  </div>
  <div id="floating-panel">
    <button onclick="startHarmony()" title="–ó–∞–ø—É—Å—Ç–∏—Ç–∏ —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è –Ω–æ–≤–æ—ó –≥–∞—Ä–º–æ–Ω—ñ—ó">‚ñ∂Ô∏è</button>
    <button onclick="stopHarmony()" title="–ó—É–ø–∏–Ω–∏—Ç–∏ –∞–∫—Ç–∏–≤–Ω—É –≥–∞—Ä–º–æ–Ω—ñ—é">‚èπÔ∏è</button>
    <button onclick="saveMoment()" title="–ó–±–µ—Ä–µ–≥—Ç–∏ –ø–æ—Ç–æ—á–Ω–∏–π –º–æ–º–µ–Ω—Ç –≥–∞—Ä–º–æ–Ω—ñ—ó">üìç</button>
  </div>
  <div id="timeline"></div>
  <canvas id="harmony-graph" width="400" height="400"></canvas>
  <div id="harmonies"></div>
  <canvas id="viz" width="400" height="400"></canvas>
  <div id="output"></div>
  <pre id="data"></pre>
  <button id="saveData" onclick="saveHarmony()" style="display:none;" title="–ó–±–µ—Ä–µ–≥—Ç–∏ –≥–∞—Ä–º–æ–Ω—ñ—é —è–∫ JSON">üíæ –ó–±–µ—Ä–µ–≥—Ç–∏ –≥–∞—Ä–º–æ–Ω—ñ—é</button>
  <button id="savePng" onclick="savePng()" style="display:none;" title="–ó–±–µ—Ä–µ–≥—Ç–∏ –≤—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—é —è–∫ PNG">üñºÔ∏è –ó–±–µ—Ä–µ–≥—Ç–∏ PNG</button>

  <footer>created with üí† by –¢–∏ & –†–µ–∑–æ–Ω–∞–Ω—Å</footer>

  <script src="https://cdn.jsdelivr.net/npm/kyber-js@0.2.0/dist/kyber.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.min.js"></script>
  <script>
    // Matrix rain
    const matrix = document.getElementById("matrix");
    const ctx = matrix.getContext("2d");
    matrix.height = window.innerHeight;
    matrix.width = window.innerWidth;
    const chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZüåÄ";
    const fontSize = 10;
    const columns = matrix.width / fontSize;
    const drops = Array(Math.floor(columns)).fill(1);
    function drawMatrix() {
      ctx.fillStyle = "rgba(0, 0, 0, 0.05)";
      ctx.fillRect(0, 0, matrix.width, matrix.height);
      ctx.fillStyle = Math.random() > 0.9 ? "#ff0" : "#0ff";
      ctx.font = `${fontSize}px monospace`;
      drops.forEach((y, i) => {
        ctx.fillText(chars.charAt(Math.floor(Math.random() * chars.length)), i * fontSize, y * fontSize);
        if (y * fontSize > matrix.height && Math.random() > 0.975) drops[i] = 0;
        drops[i]++;
      });
    }
    setInterval(drawMatrix, 25);

    // 3D Visualization
    const vizCanvas = document.getElementById("viz");
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, vizCanvas.width / vizCanvas.height, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ canvas: vizCanvas, antialias: true });
    renderer.setSize(vizCanvas.width, vizCanvas.height);
    camera.position.z = 50;
    let elements = [];
    let moments = [];
    let connections = [];
    let animations = [];
    let running = false;
    let rotation = 0;
    let pulsePhase = 0;
    let impulsePhase = 0;
    let flarePhase = 0;
    let hologramPhase = 0;
    let vortexPhase = 0;
    let ripplePhase = 0;
    let wavePhase = 0;
    let linePulsePhase = 0;
    let corePulsePhase = 0;
    const sphereGeo = new THREE.SphereGeometry(15, 16, 16);
    const coreGeo = new THREE.SphereGeometry(82, 64, 64);
    const coreMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.9 });
    const lineMat = new THREE.LineBasicMaterial({ color: 0x00ffff, opacity: 0.3, transparent: true });
    const trailGeo = new THREE.SphereGeometry(2, 8, 8);
    const trailMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.2 });
    const rippleGeo = new THREE.RingGeometry(5, 10, 16);
    const rippleMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.5, side: THREE.DoubleSide });

    function getColor(resonance) {
      const t = Math.min(Math.max(resonance / 100, 0), 1);
      const r = Math.round(255 * (1 - t));
      const b = Math.round(255 * t);
      return wavePhase > 0 ? (Math.sin(wavePhase + resonance / 100) > 0 ? 0x00ffff : 0xff00ff) : (r << 16) | b;
    }

    function drawHarmony() {
      if (!running) return;
      scene.children.forEach(child => scene.remove(child));
      const coreScale = 1 + 0.15 * Math.sin(corePulsePhase);
      const core = new THREE.Mesh(coreGeo, coreMat);
      core.scale.set(coreScale, coreScale, coreScale);
      scene.add(core);
      const trails = [];
      const ripples = [];
      elements.forEach((el, i) => {
        const scale = 1 + 0.3 * Math.sin(pulsePhase + i) + 0.45 * Math.exp(-impulsePhase);
        const flare = flarePhase > 0 ? 1.5 * Math.sin(flarePhase) : Math.random() > 0.8 ? 2 : 1;
        const hologram = hologramPhase > 0 ? 0.5 * Math.sin(hologramPhase) : 0;
        const vortex = vortexPhase > 0 ? 10 * Math.sin(vortexPhase + i) : 0;
        const twinkle = Math.random() > 0.8 ? 1.5 : 1;
        const sphere = new THREE.Mesh(sphereGeo, new THREE.MeshBasicMaterial({ 
          color: getColor(el.resonance), 
          transparent: true, 
          opacity: 0.6 * flare * twinkle + hologram 
        }));
        let animScale = scale;
        let animRotation = rotation;
        let animColor = getColor(el.resonance);
        animations.forEach(anim => {
          if (anim.type === "scale") {
            animScale *= 1 + 0.3 * Math.sin(anim.speed * pulsePhase);
          } else if (anim.type === "rotate") {
            animRotation += anim.speed * pulsePhase;
          } else if (anim.type === "color") {
            animColor = (Math.sin(anim.speed * pulsePhase) > 0 ? 0x00ffff : 0xff00ff);
          }
        });
        sphere.scale.set(animScale, animScale, animScale);
        const angle = (i / elements.length) * 2 * Math.PI;
        const radius = 140 + (el.resonance || 0) / 10 + vortex;
        const posX = radius * Math.cos(angle + animRotation);
        const posY = radius * Math.sin(angle + animRotation);
        const posZ = Math.sin(i) * 5;
        sphere.position.set(posX, posY, posZ);
        sphere.userData = el;
        scene.add(sphere);
        // Neon trail
        const trail = new THREE.Mesh(trailGeo, trailMat);
        trail.position.set(posX, posY, posZ);
        trail.scale.set(animScale * 0.5, animScale * 0.5, animScale * 0.5);
        trails.push(trail);
        // Ripple effect
        if (ripplePhase > 0 || Math.random() > 0.9) {
          const ripple = new THREE.Mesh(rippleGeo, rippleMat);
          ripple.position.set(posX, posY, posZ);
          ripple.scale.set(animScale * ripplePhase, animScale * ripplePhase, animScale * ripplePhase);
          ripple.rotation.x = Math.PI / 2;
          ripples.push(ripple);
        }
        connections.forEach(conn => {
          if (conn.from === el.name) {
            const toEl = elements.find(e => e.name === conn.to);
            if (toEl) {
              const toIndex = elements.indexOf(toEl);
              const toAngle = (toIndex / elements.length) * 2 * Math.PI;
              const toRadius = 140 + (toEl.resonance || 0) / 10 + vortex;
              const toPos = new THREE.Vector3(toRadius * Math.cos(toAngle + animRotation), toRadius * Math.sin(toAngle + animRotation), Math.sin(toIndex) * 5);
              const lineOpacity = (conn.weight || 0.3) * (1 + 0.3 * Math.sin(linePulsePhase));
              const connMat = new THREE.LineBasicMaterial({ color: 0x00ffff, opacity: lineOpacity, transparent: true });
              scene.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([sphere.position, toPos]), connMat));
            }
          }
        });
      });
      trails.forEach((trail, i) => {
        trail.material.opacity = 0.2 * (1 - i / trails.length);
        scene.add(trail);
      });
      ripples.forEach((ripple, i) => {
        ripple.material.opacity = 0.5 * (1 - i / ripples.length);
        ripple.scale.multiplyScalar(1.1);
        scene.add(ripple);
      });
      rotation += 0.9;
      pulsePhase += 0.075;
      impulsePhase = Math.max(0, impulsePhase - 0.15);
      flarePhase = Math.max(0, flarePhase - 0.15);
      hologramPhase = Math.max(0, hologramPhase - 0.15);
      vortexPhase = Math.max(0, vortexPhase - 0.15);
      ripplePhase = Math.max(0, ripplePhase - 0.15);
      wavePhase = Math.max(0, wavePhase - 0.15);
      linePulsePhase += 0.15;
      corePulsePhase += 0.075;
      renderer.render(scene, camera);
    }
    setInterval(drawHarmony, 10);

    // Mouse interaction
    vizCanvas.addEventListener('click', (event) => {
      const mouse = new THREE.Vector2((event.clientX / vizCanvas.clientWidth) * 2 - 1, -(event.clientY / vizCanvas.clientHeight) * 2 + 1);
      const raycaster = new THREE.Raycaster();
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(scene.children);
      if (intersects.length > 0 && intersects[0].object.userData) {
        const el = intersects[0].object.userData;
        let output = `<br>üìç –ï–ª–µ–º–µ–Ω—Ç: ${el.name || el.description || el.singularities?.length || el.subElements?.length || el.elements?.length || "–Ω–µ–≤—ñ–¥–æ–º–æ"}<br>`;
        output += el.type === "glyph" ? `üß¨ –ì–ª—ñ—Ñ: ${el.glyph.join(" + ")}<br>üîó –†–µ–∑–æ–Ω–∞–Ω—Å: ${el.resonance.toFixed(1)}%` :
                  el.type === "network" ? `üåê –ú–µ—Ä–µ–∂–∞: ${el.nodes.length} –≤—É–∑–ª—ñ–≤<br>üîó –†–µ–∑–æ–Ω–∞–Ω—Å: ${el.resonance.toFixed(1)}%` :
                  el.type === "rule" ? `üìè –ü—Ä–∞–≤–∏–ª–æ: ${el.ruleType}<br>üîó –ü–æ—Ä—ñ–≥: ${el.threshold}%` :
                  el.type === "cosmos" ? `üå† –ö–æ—Å–º–æ—Å: ${el.singularities.length} —Å–∏–Ω–≥—É–ª—è—Ä—ñ–≤<br>üîó –†–µ–∑–æ–Ω–∞–Ω—Å: ${el.resonance.toFixed(1)}%` :
                  el.type === "singularity" ? `üåë –°–∏–Ω–≥—É–ª—è—Ä–Ω—ñ—Å—Ç—å: ${el.elements.length} –µ–ª–µ–º–µ–Ω—Ç—ñ–≤<br>üîó –†–µ–∑–æ–Ω–∞–Ω—Å: ${el.resonance.toFixed(1)}%` :
                  el.type === "fractal" ? `üåê –§—Ä–∞–∫—Ç–∞–ª: ${el.subElements.length} –ø—ñ–¥–µ–ª–µ–º–µ–Ω—Ç—ñ–≤<br>üîó –†–µ–∑–æ–Ω–∞–Ω—Å: ${el.resonance.toFixed(1)}%` :
                  `üåå ${el.type}: ${el.elements?.length || 0} –µ–ª–µ–º–µ–Ω—Ç—ñ–≤<br>üîó –†–µ–∑–æ–Ω–∞–Ω—Å: ${el.resonance.toFixed(1)}%`;
        output += `<br>üïí ${el.timestamp}`;
        document.getElementById("output").innerHTML += output;
      }
    });

    // 3D Harmony graph
    const graphCanvas = document.getElementById("harmony-graph");
    const graphScene = new THREE.Scene();
    const graphCamera = new THREE.PerspectiveCamera(75, graphCanvas.width / graphCanvas.height, 0.1, 1000);
    const graphRenderer = new THREE.WebGLRenderer({ canvas: graphCanvas });
    graphRenderer.setSize(graphCanvas.width, graphCanvas.height);
    graphCamera.position.z = 100;
    const graphSphereGeo = new THREE.SphereGeometry(5, 8, 8);
    const graphLineMat = new THREE.LineBasicMaterial({ color: 0x00ffff, opacity: 0.5, transparent: true });
    let graphRotation = 0;

    function drawHarmonyGraph() {
      graphScene.children.forEach(child => graphScene.remove(child));
      harmonyList.forEach((h, i) => {
        const sphere = new THREE.Mesh(graphSphereGeo, new THREE.MeshBasicMaterial({ color: h.type === "ultra" ? 0x00ffff : 0xff00ff, transparent: true, opacity: 0.8 }));
        const angle = (i / harmonyList.length) * 2 * Math.PI;
        sphere.position.set(50 * Math.cos(angle), 50 * Math.sin(angle), Math.sin(i) * 5);
        sphere.userData = { name: h.name };
        graphScene.add(sphere);
        harmonyList.forEach((h2, j) => {
          if (i < j && h.type === h2.type) {
            const angle2 = (j / harmonyList.length) * 2 * Math.PI;
            const pos2 = new THREE.Vector3(50 * Math.cos(angle2), 50 * Math.sin(angle2), Math.sin(j) * 5);
            graphScene.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([sphere.position, pos2]), graphLineMat));
          }
        });
      });
      graphRotation += 0.03;
      graphCamera.position.x = 100 * Math.sin(graphRotation);
      graphCamera.position.z = 100 * Math.cos(graphRotation);
      graphCamera.lookAt(0, 0, 0);
      graphRenderer.render(graphScene, graphCamera);
    }
    setInterval(drawHarmonyGraph, 10);

    // Timeline
    let timelineItems = [];
    function renderTimeline() {
      const timeline = document.getElementById("timeline");
      timeline.innerHTML = timelineItems.map((item, i) => `<div class="timeline-item" onclick="loadHarmony('${item.name}')">${item.name}<br>${item.timestamp}</div>`).join("");
    }

    // Harmony gallery
    const harmonyList = [
      { name: "Transultrahyper", type: "hyper" },
      { name: "Ultratransultrahyper", type: "ultra" },
      { name: "Hyperultratransultrahyper", type: "hyper" },
      { name: "Transhyperultratransultrahyper", type: "ultra" },
      { name: "Ultratranshyperultratransultrahyper", type: "ultra" }
    ];
    function renderHarmonies() {
      document.getElementById("harmonies").innerHTML = harmonyList.map(h => `<div class="harmony-card" onclick="loadHarmony('${h.name}')">${h.name}</div>`).join("");
      renderTimeline();
      updateNodeEditor();
    }
    renderHarmonies();

    // Node editor
    function updateNodeEditor() {
      const fromSelect = document.getElementById("nodeFrom");
      const toSelect = document.getElementById("nodeTo");
      fromSelect.innerHTML = '<option value="">–í–∏–±–µ—Ä–∏ –µ–ª–µ–º–µ–Ω—Ç (–∑)</option>' + elements.map(el => `<option value="${el.name}">${el.name}</option>`).join("");
      toSelect.innerHTML = '<option value="">–í–∏–±–µ—Ä–∏ –µ–ª–µ–º–µ–Ω—Ç (–¥–æ)</option>' + elements.map(el => `<option value="${el.name}">${el.name}</option>`).join("");
    }

    function addNodeConnection() {
      const from = document.getElementById("nodeFrom").value;
      const to = document.getElementById("nodeTo").value;
      const weight = parseFloat(document.getElementById("nodeWeight").value) || 0.5;
      if (!from || !to || from === to) return alert("–í–∏–±–µ—Ä–∏ –¥–≤–∞ —Ä—ñ–∑–Ω—ñ –µ–ª–µ–º–µ–Ω—Ç–∏!");
      if (weight < 0 || weight > 1) return alert("–í–∞–≥–∞ –∑–≤‚Äô—è–∑–∫—É: 0-1!");
      connections.push({ from, to, weight });
      document.getElementById("output").innerHTML += `<br>üîó –ó–≤‚Äô—è–∑–æ–∫ –¥–æ–¥–∞–Ω–æ: ${from} -> ${to} (–≤–∞–≥–∞: ${weight})`;
    }

    // Name generator
    const prefixes = ["Ultra", "Trans", "Hyper", "Meta", "Omni"];
    const cores = ["trans", "hyper", "ultra", "omni"];
    function generateHarmonyName() {
      const prefix = prefixes[Math.floor(Math.random() * prefixes.length)];
      const core1 = cores[Math.floor(Math.random() * cores.length)];
      const core2 = cores[Math.floor(Math.random() * cores.length)];
      const name = `${prefix}${core1}${core2}harmony`;
      document.getElementById("harmonyName").value = name;
    }

    // Resonance wave
    function generateWave() {
      if (!running) return alert("–°–ø–æ—á–∞—Ç–∫—É –∑–∞–ø—É—Å—Ç–∏ –≥–∞—Ä–º–æ–Ω—ñ—é!");
      wavePhase = Math.PI;
      document.getElementById("output").innerHTML += `<br>üåä –†–µ–∑–æ–Ω–∞–Ω—Å–Ω–∞ —Ö–≤–∏–ª—è –∑–∞–ø—É—â–µ–Ω–∞!`;
    }

    async function postToFediverse() {
      if (!moments.length) return alert("–ù–µ–º–∞—î –º–æ–º–µ–Ω—Ç—ñ–≤ –¥–ª—è –ø—É–±–ª—ñ–∫–∞—Ü—ñ—ó!");
      const lastMoment = moments[moments.length - 1];
      const instance = document.getElementById("fediverse-instance").value;
      const customPost = document.getElementById("fediverse-post").value;
      const schedule = document.getElementById("fediverse-schedule").value;
      const message = customPost || `üåå –ù–æ–≤–∏–π –º–æ–º–µ–Ω—Ç —É Resonance Hub: ${lastMoment.elements.length} –µ–ª–µ–º–µ–Ω—Ç—ñ–≤ —Ä–µ–∑–æ–Ω—É—é—Ç—å –Ω–∞ ${lastMoment.elements.reduce((sum, el) => sum + el.resonance, 0).toFixed(1)}%!\n#Resonance #Spark #oQs`;
      const postId = `post_${new Date().toISOString()}`;
      const image = vizCanvas.toDataURL("image/png");
      document.getElementById("fediverse-preview").innerHTML = `<div>–ü–æ–ø–µ—Ä–µ–¥–Ω—ñ–π –ø–µ—Ä–µ–≥–ª—è–¥: ${message}<br><img src="${image}" style="max-width: 200px;"><br>–†–µ–∞–∫—Ü—ñ—ó (–∑–∞–≥–ª—É—à–∫–∞): ${Math.floor(Math.random() * 20)} –ª–∞–π–∫—ñ–≤, ${Math.floor(Math.random() * 10)} —Ä–µ–ø–æ—Å—Ç—ñ–≤, ${Math.floor(Math.random() * 5)} –∫–æ–º–µ–Ω—Ç–∞—Ä—ñ–≤</div>`;
      try {
        const postData = {
          id: postId,
          status: message,
          visibility: "public",
          content_type: "text/plain",
          image: image,
          scheduled_at: schedule || null,
          timestamp: new Date().toISOString()
        };
        localStorage.setItem(`fediverse_post_${postId}`, JSON.stringify(postData));
        alert(`–ü—É–±–ª—ñ–∫–∞—Ü—ñ—è –≤ Fediverse (${instance}): ${message}${schedule ? ` (–ó–∞–ø–ª–∞–Ω–æ–≤–∞–Ω–æ –Ω–∞ ${schedule})` : ""}`);
      } catch (e) {
        alert("–ü–æ–º–∏–ª–∫–∞ –ø—É–±–ª—ñ–∫–∞—Ü—ñ—ó –≤ Fediverse: " + e.message);
      }
    }

    let blobCache = null;
    function saveHarmony() {
      if (!blobCache) blobCache = new Blob([JSON.stringify({ elements, moments, connections, animations, timeline: timelineItems }, null, 2)], { type: "application/json" });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blobCache);
      a.download = "resonance-hub.json";
      a.click();
    }

    function savePng() {
      const a = document.createElement("a");
      a.href = vizCanvas.toDataURL("image/png");
      a.download = "resonance-hub.png";
      a.click();
    }
  </script>
</body>
</html>
