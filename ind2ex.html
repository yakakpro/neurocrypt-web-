<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#0c0c0c">
  <title>üåå Resonance Hub ‚àû v16</title>
  <style>
    body {
      background: #0c0c0c;
      color: #e0e0e0;
      font-family: 'Segoe UI', Arial, sans-serif;
      padding: 50px 30px;
      max-width: 800px;
      margin: auto;
      text-align: center;
      position: relative;
      overflow-x: hidden;
    }
    #matrix {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      opacity: 0.1;
      z-index: -1;
    }
    h1 {
      font-size: 2em;
      margin-bottom: 30px;
      animation: glitch 8s infinite;
    }
    canvas {
      display: block;
      margin: 20px auto;
      border: 1px solid #555;
      background: #000;
      animation: pulse 6s infinite, glitch 8s infinite;
    }
    button, input, select, textarea {
      background: #1a1a1a;
      color: #eee;
      padding: 15px;
      border: 1px solid #444;
      margin: 15px;
      cursor: pointer;
      font-size: 1em;
      width: 80%;
      animation: glitch 8s infinite;
    }
    button:hover, input:hover, select:hover, textarea:hover {
      background: #333;
      transform: scale(1.05);
      transition: all 0.3s;
    }
    .scroll-button {
      position: sticky;
      top: 10px;
      z-index: 10;
      width: 40px;
      height: 40px;
      padding: 10px;
      font-size: 0.8em;
      border: 2px solid #0ff;
      background: #0c0c0c;
      animation: glitch 8s infinite, neon-pulse 2s infinite;
    }
    #scroll-buttons {
      display: flex;
      justify-content: center;
      gap: 10px;
    }
    #resonance-slider, #element-editor, #timeline, #node-editor, #pattern-editor, #animation-editor, #fediverse-preview {
      width: 80%;
      margin: 15px auto;
    }
    #timeline {
      display: flex;
      overflow-x: auto;
      gap: 10px;
    }
    .timeline-item {
      background: #1a1a1a;
      padding: 10px;
      border: 1px solid #444;
      cursor: pointer;
      animation: glitch 8s infinite;
      transition: all 0.3s;
    }
    .timeline-item:hover {
      background: #333;
      transform: scale(1.05);
    }
    #output {
      text-align: center;
      margin-top: 20px;
      font-size: 1.2em;
      animation: glitch 8s infinite;
    }
    #harmonies {
      display: grid;
      gap: 15px;
      margin: 20px 0;
    }
    .harmony-card {
      background: #1a1a1a;
      padding: 15px;
      border: 1px solid #444;
      cursor: pointer;
      animation: glitch 8s infinite;
      transition: all 0.3s;
    }
    .harmony-card:hover {
      background: #333;
      transform: scale(1.05);
    }
    pre {
      background: #111;
      padding: 10px;
      overflow-x: auto;
      margin-top: 20px;
      display: none;
    }
    footer {
      margin-top: 60px;
      font-size: 0.8em;
      color: #555;
      animation: glitch 8s infinite;
    }
    @keyframes glitch {
      0% { transform: translate(0); opacity: 1; }
      2% { transform: translate(1px, 1px); opacity: 0.95; }
      4% { transform: translate(-1px, -1px); opacity: 0.95; }
      6% { transform: translate(0); opacity: 1; }
      100% { transform: translate(0); opacity: 1; }
    }
    @keyframes pulse {
      0% { filter: brightness(1); }
      50% { filter: brightness(1.5); }
      100% { filter: brightness(1); }
    }
    @keyframes neon-pulse {
      0% { box-shadow: 0 0 5px #0ff; }
      50% { box-shadow: 0 0 10px #0ff; }
      100% { box-shadow: 0 0 5px #0ff; }
    }
  </style>
</head>
<body>
  <canvas id="matrix"></canvas>
  <h1>üåå Resonance Hub ‚àû v16</h1>
  <p>–í–∏—Ö—Ä–æ–≤–∏–π –≥–æ–ª–æ–≥—Ä–∞—Ñ—ñ—á–Ω–∏–π –∫–∞—Å–∫–∞–¥ ‚Äî —Ç–≤–æ—Ä–∏, —Ä–µ–∑–æ–Ω—É–π, –æ–±‚Äô—î–¥–Ω—É–π –≤—ñ—á–Ω—ñ—Å—Ç—å!</p>

  <div id="scroll-buttons">
    <button class="scroll-button" onclick="scrollToTop()">üîº</button>
    <button class="scroll-button" onclick="scrollToBottom()">üîΩ</button>
  </div>
  <div>
    <input type="text" id="harmonyName" placeholder="–ù–∞–∑–≤–∞ –≥–∞—Ä–º–æ–Ω—ñ—ó">
    <button onclick="generateHarmonyName()">üé≤ –ó–≥–µ–Ω–µ—Ä—É–≤–∞—Ç–∏ –Ω–∞–∑–≤—É</button>
    <input type="number" id="entropy" placeholder="–ï–Ω—Ç—Ä–æ–ø—ñ—è (0-1)" min="0" max="1" step="0.1">
    <input type="number" id="level" placeholder="–†—ñ–≤–µ–Ω—å (0-10)" min="0" max="10" step="1">
    <input type="range" id="resonance-slider" min="0" max="100" value="60" oninput="updateResonance(this.value)">
    <select id="fusion">
      <option value="ultra">–£–ª—å—Ç—Ä–∞–≥–∞—Ä–º–æ–Ω—ñ—ó</option>
      <option value="hyper">–ì—ñ–ø–µ—Ä–≥–∞—Ä–º–æ–Ω—ñ—ó</option>
      <option value="all">–£—Å–µ</option>
    </select>
    <div id="element-editor">
      <input type="text" id="elementName" placeholder="–ù–∞–∑–≤–∞ –µ–ª–µ–º–µ–Ω—Ç–∞">
      <select id="elementType">
        <option value="glyph">–ì–ª—ñ—Ñ</option>
        <option value="network">–ú–µ—Ä–µ–∂–∞</option>
        <option value="rule">–ü—Ä–∞–≤–∏–ª–æ</option>
        <option value="cosmos">–ö–æ—Å–º–æ—Å</option>
      </select>
      <button onclick="addElement()">‚ûï –î–æ–¥–∞—Ç–∏ –µ–ª–µ–º–µ–Ω—Ç</button>
    </div>
    <div id="node-editor">
      <select id="nodeFrom">
        <option value="">–í–∏–±–µ—Ä–∏ –µ–ª–µ–º–µ–Ω—Ç (–∑)</option>
      </select>
      <select id="nodeTo">
        <option value="">–í–∏–±–µ—Ä–∏ –µ–ª–µ–º–µ–Ω—Ç (–¥–æ)</option>
      </select>
      <input type="number" id="nodeWeight" placeholder="–í–∞–≥–∞ –∑–≤‚Äô—è–∑–∫—É (0-1)" min="0" max="1" step="0.1">
      <button onclick="addNodeConnection()">üîó –î–æ–¥–∞—Ç–∏ –∑–≤‚Äô—è–∑–æ–∫</button>
    </div>
    <div id="pattern-editor">
      <select id="patternType">
        <option value="sine">–°–∏–Ω—É—Å–æ—ó–¥–∞–ª—å–Ω–∏–π</option>
        <option value="exp">–ï–∫—Å–ø–æ–Ω–µ–Ω—Ü—ñ–∞–ª—å–Ω–∏–π</option>
        <option value="chaos">–•–∞–æ—Ç–∏—á–Ω–∏–π</option>
      </select>
      <input type="number" id="patternAmplitude" placeholder="–ê–º–ø–ª—ñ—Ç—É–¥–∞ (0-10)" min="0" max="10" step="1">
      <button onclick="applyPattern()">üé® –ó–∞—Å—Ç–æ—Å—É–≤–∞—Ç–∏ –ø–∞—Ç–µ—Ä–Ω</button>
    </div>
    <div id="animation-editor">
      <select id="animationType">
        <option value="rotate">–û–±–µ—Ä—Ç–∞–Ω–Ω—è</option>
        <option value="scale">–ú–∞—Å—à—Ç–∞–±—É–≤–∞–Ω–Ω—è</option>
        <option value="color">–ó–º—ñ–Ω–∞ –∫–æ–ª—å–æ—Ä—É</option>
      </select>
      <input type="number" id="animationSpeed" placeholder="–®–≤–∏–¥–∫—ñ—Å—Ç—å (0-10)" min="0" max="10" step="1">
      <button onclick="applyAnimation()">üé¨ –ó–∞—Å—Ç–æ—Å—É–≤–∞—Ç–∏ –∞–Ω—ñ–º–∞—Ü—ñ—é</button>
    </div>
    <button onclick="startHarmony()">‚ñ∂Ô∏è –°—Ç–≤–æ—Ä–∏—Ç–∏ –≥–∞—Ä–º–æ–Ω—ñ—é</button>
    <button onclick="stopHarmony()">‚èπÔ∏è –ó—É–ø–∏–Ω–∏—Ç–∏</button>
    <button onclick="saveMoment()">üìç –ó–±–µ—Ä–µ–≥—Ç–∏ –º–æ–º–µ–Ω—Ç</button>
    <button onclick="generateSingularity()">üåë –°—Ç–≤–æ—Ä–∏—Ç–∏ —Å–∏–Ω–≥—É–ª—è—Ä–Ω—ñ—Å—Ç—å</button>
    <button onclick="generateFractal()">üåê –°—Ç–≤–æ—Ä–∏—Ç–∏ —Ñ—Ä–∞–∫—Ç–∞–ª</button>
    <button onclick="generateNeuralLink()">üß† –°—Ç–≤–æ—Ä–∏—Ç–∏ –Ω–µ–π—Ä–æ–Ω–Ω–∏–π –∑–≤‚Äô—è–∑–æ–∫</button>
    <button onclick="generatePulse()">üí• –ó–∞–ø—É—Å—Ç–∏—Ç–∏ —ñ–º–ø—É–ª—å—Å</button>
    <button onclick="generateFlare()">‚ú® –ó–∞–ø—É—Å—Ç–∏—Ç–∏ —Å–ø–∞–ª–∞—Ö</button>
    <button onclick="generateHologram()">üå† –ó–∞–ø—É—Å—Ç–∏—Ç–∏ –≥–æ–ª–æ–≥—Ä–∞–º—É</button>
    <button onclick="generateVortex()">üåÄ –ó–∞–ø—É—Å—Ç–∏—Ç–∏ –≤–∏—Ö–æ—Ä</button>
    <button onclick="generateLinePulse()">üåå –ü—É–ª—å—Å–∞—Ü—ñ—è –ª—ñ–Ω—ñ–π</button>
    <button onclick="showPostHistory()">üìú –Ü—Å—Ç–æ—Ä—ñ—è –ø–æ—Å—Ç—ñ–≤</button>
    <select id="fediverse-instance">
      <option value="mastodon.social">mastodon.social</option>
      <option value="pleroma.instance">pleroma.instance</option>
    </select>
    <textarea id="fediverse-post" placeholder="–ö–∞—Å—Ç–æ–º–Ω–∏–π –ø–æ—Å—Ç –¥–ª—è Fediverse"></textarea>
    <input type="datetime-local" id="fediverse-schedule" placeholder="–ó–∞–ø–ª–∞–Ω—É–≤–∞—Ç–∏ –ø–æ—Å—Ç">
    <div id="fediverse-preview"></div>
    <button onclick="postToFediverse()">üì° –ü–æ–¥—ñ–ª–∏—Ç–∏—Å—è –≤ Fediverse</button>
  </div>
  <div id="timeline"></div>
  <canvas id="harmony-graph" width="400" height="400"></canvas>
  <div id="harmonies"></div>
  <canvas id="viz" width="400" height="400"></canvas>
  <div id="output"></div>
  <pre id="data"></pre>
  <button id="saveData" onclick="saveHarmony()" style="display:none;">üíæ –ó–±–µ—Ä–µ–≥—Ç–∏ –≥–∞—Ä–º–æ–Ω—ñ—é</button>
  <button id="savePng" onclick="savePng()" style="display:none;">üñºÔ∏è –ó–±–µ—Ä–µ–≥—Ç–∏ PNG</button>

  <footer>created with üí† by –¢–∏ & –†–µ–∑–æ–Ω–∞–Ω—Å</footer>

  <script src="https://cdn.jsdelivr.net/npm/kyber-js@0.2.0/dist/kyber.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.min.js"></script>
  <script>
    // Matrix rain
    const matrix = document.getElementById("matrix");
    const ctx = matrix.getContext("2d");
    matrix.height = window.innerHeight;
    matrix.width = window.innerWidth;
    const chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZüåÄ";
    const fontSize = 10;
    const columns = matrix.width / fontSize;
    const drops = Array(Math.floor(columns)).fill(1);
    function drawMatrix() {
      ctx.fillStyle = "rgba(0, 0, 0, 0.05)";
      ctx.fillRect(0, 0, matrix.width, matrix.height);
      ctx.fillStyle = "#0ff";
      ctx.font = `${fontSize}px monospace`;
      drops.forEach((y, i) => {
        ctx.fillText(chars.charAt(Math.floor(Math.random() * chars.length)), i * fontSize, y * fontSize);
        if (y * fontSize > matrix.height && Math.random() > 0.975) drops[i] = 0;
        drops[i]++;
      });
    }
    setInterval(drawMatrix, 33); // –ü—Ä–∏—Å–∫–æ—Ä–µ–Ω–æ –Ω–∞ 50%

    // Scroll functions
    function scrollToBottom() {
      window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
    }
    function scrollToTop() {
      window.scrollTo({ top: 0, behavior: 'smooth' });
    }

    // 3D Visualization
    const vizCanvas = document.getElementById("viz");
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, vizCanvas.width / vizCanvas.height, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ canvas: vizCanvas, antialias: true });
    renderer.setSize(vizCanvas.width, vizCanvas.height);
    camera.position.z = 50;
    let elements = [];
    let moments = [];
    let connections = [];
    let animations = [];
    let running = false;
    let rotation = 0;
    let pulsePhase = 0;
    let impulsePhase = 0;
    let flarePhase = 0;
    let hologramPhase = 0;
    let vortexPhase = 0;
    let linePulsePhase = 0;
    let corePulsePhase = 0;
    const sphereGeo = new THREE.SphereGeometry(14.8, 16, 16);
    const coreGeo = new THREE.SphereGeometry(80, 64, 64);
    const coreMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.9 });
    const lineMat = new THREE.LineBasicMaterial({ color: 0x00ffff, opacity: 0.3, transparent: true });
    const trailGeo = new THREE.SphereGeometry(2, 8, 8);
    const trailMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.2 });

    function getColor(resonance) {
      const t = Math.min(Math.max(resonance / 100, 0), 1);
      const r = Math.round(255 * (1 - t));
      const b = Math.round(255 * t);
      return (r << 16) | b;
    }

    function drawHarmony() {
      if (!running) return;
      scene.children.forEach(child => scene.remove(child));
      const coreScale = 1 + 0.1 * Math.sin(corePulsePhase);
      const core = new THREE.Mesh(coreGeo, coreMat);
      core.scale.set(coreScale, coreScale, coreScale);
      scene.add(core);
      const trails = [];
      elements.forEach((el, i) => {
        const scale = 1 + 0.3 * Math.sin(pulsePhase + i) + 0.45 * Math.exp(-impulsePhase);
        const flare = flarePhase > 0 ? 1.5 * Math.sin(flarePhase) : 1;
        const hologram = hologramPhase > 0 ? 0.5 * Math.sin(hologramPhase) : 0;
        const vortex = vortexPhase > 0 ? 10 * Math.sin(vortexPhase + i) : 0;
        const sphere = new THREE.Mesh(sphereGeo, new THREE.MeshBasicMaterial({ 
          color: getColor(el.resonance), 
          transparent: true, 
          opacity: 0.6 * flare + hologram 
        }));
        let animScale = scale;
        let animRotation = rotation;
        let animColor = getColor(el.resonance);
        animations.forEach(anim => {
          if (anim.type === "scale") {
            animScale *= 1 + 0.3 * Math.sin(anim.speed * pulsePhase);
          } else if (anim.type === "rotate") {
            animRotation += anim.speed * pulsePhase;
          } else if (anim.type === "color") {
            animColor = (Math.sin(anim.speed * pulsePhase) > 0 ? 0x00ffff : 0xff00ff);
          }
        });
        sphere.scale.set(animScale, animScale, animScale);
        const angle = (i / elements.length) * 2 * Math.PI;
        const radius = 138 + (el.resonance || 0) / 10 + vortex;
        const posX = radius * Math.cos(angle + animRotation);
        const posY = radius * Math.sin(angle + animRotation);
        const posZ = Math.sin(i) * 5;
        sphere.position.set(posX, posY, posZ);
        sphere.userData = el;
        scene.add(sphere);
        // Neon trail
        const trail = new THREE.Mesh(trailGeo, trailMat);
        trail.position.set(posX, posY, posZ);
        trail.scale.set(animScale * 0.5, animScale * 0.5, animScale * 0.5);
        trails.push(trail);
        connections.forEach(conn => {
          if (conn.from === el.name) {
            const toEl = elements.find(e => e.name === conn.to);
            if (toEl) {
              const toIndex = elements.indexOf(toEl);
              const toAngle = (toIndex / elements.length) * 2 * Math.PI;
              const toRadius = 138 + (toEl.resonance || 0) / 10 + vortex;
              const toPos = new THREE.Vector3(toRadius * Math.cos(toAngle + animRotation), toRadius * Math.sin(toAngle + animRotation), Math.sin(toIndex) * 5);
              const lineOpacity = (conn.weight || 0.3) * (1 + 0.3 * Math.sin(linePulsePhase));
              const connMat = new THREE.LineBasicMaterial({ color: 0x00ffff, opacity: lineOpacity, transparent: true });
              scene.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([sphere.position, toPos]), connMat));
            }
          }
        });
      });
      trails.forEach((trail, i) => {
        trail.material.opacity = 0.2 * (1 - i / trails.length);
        scene.add(trail);
      });
      rotation += 0.9; // –ü—Ä–∏—Å–∫–æ—Ä–µ–Ω–æ –Ω–∞ 50%
      pulsePhase += 0.075; // –ü—Ä–∏—Å–∫–æ—Ä–µ–Ω–æ –Ω–∞ 50%
      impulsePhase = Math.max(0, impulsePhase - 0.15); // –ü—Ä–∏—Å–∫–æ—Ä–µ–Ω–æ –Ω–∞ 50%
      flarePhase = Math.max(0, flarePhase - 0.15); // –ü—Ä–∏—Å–∫–æ—Ä–µ–Ω–æ –Ω–∞ 50%
      hologramPhase = Math.max(0, hologramPhase - 0.15); // –ü—Ä–∏—Å–∫–æ—Ä–µ–Ω–æ –Ω–∞ 50%
      vortexPhase = Math.max(0, vortexPhase - 0.15); // –ü—Ä–∏—Å–∫–æ—Ä–µ–Ω–æ –Ω–∞ 50%
      linePulsePhase += 0.15; // –ü—Ä–∏—Å–∫–æ—Ä–µ–Ω–æ –Ω–∞ 50%
      corePulsePhase += 0.075; // –ü—Ä–∏—Å–∫–æ—Ä–µ–Ω–æ –Ω–∞ 50%
      renderer.render(scene, camera);
    }
    setInterval(drawHarmony, 10); // –ü—Ä–∏—Å–∫–æ—Ä–µ–Ω–æ –Ω–∞ 50%

    // Mouse interaction
    vizCanvas.addEventListener('click', (event) => {
      const mouse = new THREE.Vector2((event.clientX / vizCanvas.clientWidth) * 2 - 1, -(event.clientY / vizCanvas.clientHeight) * 2 + 1);
      const raycaster = new THREE.Raycaster();
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(scene.children);
      if (intersects.length > 0 && intersects[0].object.userData) {
        const el = intersects[0].object.userData;
        let output = `<br>üìç –ï–ª–µ–º–µ–Ω—Ç: ${el.name || el.description || el.singularities?.length || el.subElements?.length || el.elements?.length || "–Ω–µ–≤—ñ–¥–æ–º–æ"}<br>`;
        output += el.type === "glyph" ? `üß¨ –ì–ª—ñ—Ñ: ${el.glyph.join(" + ")}<br>üîó –†–µ–∑–æ–Ω–∞–Ω—Å: ${el.resonance.toFixed(1)}%` :
                  el.type === "network" ? `üåê –ú–µ—Ä–µ–∂–∞: ${el.nodes.length} –≤—É–∑–ª—ñ–≤<br>üîó –†–µ–∑–æ–Ω–∞–Ω—Å: ${el.resonance.toFixed(1)}%` :
                  el.type === "rule" ? `üìè –ü—Ä–∞–≤–∏–ª–æ: ${el.ruleType}<br>üîó –ü–æ—Ä—ñ–≥: ${el.threshold}%` :
                  el.type === "cosmos" ? `üå† –ö–æ—Å–º–æ—Å: ${el.singularities.length} —Å–∏–Ω–≥—É–ª—è—Ä—ñ–≤<br>üîó –†–µ–∑–æ–Ω–∞–Ω—Å: ${el.resonance.toFixed(1)}%` :
                  el.type === "singularity" ? `üåë –°–∏–Ω–≥—É–ª—è—Ä–Ω—ñ—Å—Ç—å: ${el.elements.length} –µ–ª–µ–º–µ–Ω—Ç—ñ–≤<br>üîó –†–µ–∑–æ–Ω–∞–Ω—Å: ${el.resonance.toFixed(1)}%` :
                  el.type === "fractal" ? `üåê –§—Ä–∞–∫—Ç–∞–ª: ${el.subElements.length} –ø—ñ–¥–µ–ª–µ–º–µ–Ω—Ç—ñ–≤<br>üîó –†–µ–∑–æ–Ω–∞–Ω—Å: ${el.resonance.toFixed(1)}%` :
                  `üåå ${el.type}: ${el.elements?.length || 0} –µ–ª–µ–º–µ–Ω—Ç—ñ–≤<br>üîó –†–µ–∑–æ–Ω–∞–Ω—Å: ${el.resonance.toFixed(1)}%`;
        output += `<br>üïí ${el.timestamp}`;
        document.getElementById("output").innerHTML += output;
      }
    });

    // 3D Harmony graph
    const graphCanvas = document.getElementById("harmony-graph");
    const graphScene = new THREE.Scene();
    const graphCamera = new THREE.PerspectiveCamera(75, graphCanvas.width / graphCanvas.height, 0.1, 1000);
    const graphRenderer = new THREE.WebGLRenderer({ canvas: graphCanvas });
    graphRenderer.setSize(graphCanvas.width, graphCanvas.height);
    graphCamera.position.z = 100;
    const graphSphereGeo = new THREE.SphereGeometry(5, 8, 8);
    const graphLineMat = new THREE.LineBasicMaterial({ color: 0x00ffff, opacity: 0.5, transparent: true });
    let graphRotation = 0;

    function drawHarmonyGraph() {
      graphScene.children.forEach(child => graphScene.remove(child));
      harmonyList.forEach((h, i) => {
        const sphere = new THREE.Mesh(graphSphereGeo, new THREE.MeshBasicMaterial({ color: h.type === "ultra" ? 0x00ffff : 0xff00ff, transparent: true, opacity: 0.8 }));
        const angle = (i / harmonyList.length) * 2 * Math.PI;
        sphere.position.set(50 * Math.cos(angle), 50 * Math.sin(angle), Math.sin(i) * 5);
        sphere.userData = { name: h.name };
        graphScene.add(sphere);
        harmonyList.forEach((h2, j) => {
          if (i < j && h.type === h2.type) {
            const angle2 = (j / harmonyList.length) * 2 * Math.PI;
            const pos2 = new THREE.Vector3(50 * Math.cos(angle2), 50 * Math.sin(angle2), Math.sin(j) * 5);
            graphScene.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([sphere.position, pos2]), graphLineMat));
          }
        });
      });
      graphRotation += 0.03; // –ü—Ä–∏—Å–∫–æ—Ä–µ–Ω–æ –Ω–∞ 50%
      graphCamera.position.x = 100 * Math.sin(graphRotation);
      graphCamera.position.z = 100 * Math.cos(graphRotation);
      graphCamera.lookAt(0, 0, 0);
      graphRenderer.render(graphScene, graphCamera);
    }
    setInterval(drawHarmonyGraph, 10); // –ü—Ä–∏—Å–∫–æ—Ä–µ–Ω–æ –Ω–∞ 50%

    // Timeline
    let timelineItems = [];
    function renderTimeline() {
      const timeline = document.getElementById("timeline");
      timeline.innerHTML = timelineItems.map((item, i) => `<div class="timeline-item" onclick="loadHarmony('${item.name}')">${item.name}<br>${item.timestamp}</div>`).join("");
    }

    // Harmony gallery
    const harmonyList = [
      { name: "Transultrahyper", type: "hyper" },
      { name: "Ultratransultrahyper", type: "ultra" },
      { name: "Hyperultratransultrahyper", type: "hyper" },
      { name: "Transhyperultratransultrahyper", type: "ultra" },
      { name: "Ultratranshyperultratransultrahyper", type: "ultra" }
    ];
    function renderHarmonies() {
      document.getElementById("harmonies").innerHTML = harmonyList.map(h => `<div class="harmony-card" onclick="loadHarmony('${h.name}')">${h.name}</div>`).join("");
      renderTimeline();
      updateNodeEditor();
    }
    renderHarmonies();

    // Node editor
    function updateNodeEditor() {
      const fromSelect = document.getElementById("nodeFrom");
      const toSelect = document.getElementById("nodeTo");
      fromSelect.innerHTML = '<option value="">–í–∏–±–µ—Ä–∏ –µ–ª–µ–º–µ–Ω—Ç (–∑)</option>' + elements.map(el => `<option value="${el.name}">${el.name}</option>`).join("");
      toSelect.innerHTML = '<option value="">–í–∏–±–µ—Ä–∏ –µ–ª–µ–º–µ–Ω—Ç (–¥–æ)</option>' + elements.map(el => `<option value="${el.name}">${el.name}</option>`).join("");
    }

    function addNodeConnection() {
      const from = document.getElementById("nodeFrom").value;
      const to = document.getElementById("nodeTo").value;
      const weight = parseFloat(document.getElementById("nodeWeight").value) || 0.5;
      if (!from || !to || from === to) return alert("–í–∏–±–µ—Ä–∏ –¥–≤–∞ —Ä—ñ–∑–Ω—ñ –µ–ª–µ–º–µ–Ω—Ç–∏!");
      if (weight < 0 || weight > 1) return alert("–í–∞–≥–∞ –∑–≤‚Äô—è–∑–∫—É: 0-1!");
      connections.push({ from, to, weight });
      document.getElementById("output").innerHTML += `<br>üîó –ó–≤‚Äô—è–∑–æ–∫ –¥–æ–¥–∞–Ω–æ: ${from} -> ${to} (–≤–∞–≥–∞: ${weight})`;
    }

    // Name generator
    const prefixes = ["Ultra", "Trans", "Hyper", "Meta", "Omni"];
    const cores = ["trans", "hyper", "ultra", "omni"];
    function generateHarmonyName() {
      const prefix = prefixes[Math.floor(Math.random() * prefixes.length)];
      const core1 = cores[Math.floor(Math.random() * cores.length)];
      const core2 = cores[Math.floor(Math.random() * cores.length)];
      const name = `${prefix}${core1}${core2}harmony`;
      document.getElementById("harmonyName").value = name;
    }

    // Resonance slider
    function updateResonance(value) {
      if (!running) return;
      elements.forEach(el => el.resonance = Math.min(100, Math.max(0, parseFloat(value))));
      displayElements(elements);
    }

    // Resonance pulse
    function generatePulse() {
      if (!running) return alert("–°–ø–æ—á–∞—Ç–∫—É –∑–∞–ø—É—Å—Ç–∏ –≥–∞—Ä–º–æ–Ω—ñ—é!");
      impulsePhase = 1;
      elements.forEach(el => {
        el.resonance = Math.min(100, el.resonance + 20 * Math.exp(-impulsePhase));
      });
      displayElements(elements);
      document.getElementById("output").innerHTML += `<br>üí• –†–µ–∑–æ–Ω–∞–Ω—Å–Ω–∏–π —ñ–º–ø—É–ª—å—Å –∑–∞–ø—É—â–µ–Ω–æ!`;
    }

    // Resonance flare
    function generateFlare() {
      if (!running) return alert("–°–ø–æ—á–∞—Ç–∫—É –∑–∞–ø—É—Å—Ç–∏ –≥–∞—Ä–º–æ–Ω—ñ—é!");
      flarePhase = Math.PI;
      document.getElementById("output").innerHTML += `<br>‚ú® –†–µ–∑–æ–Ω–∞–Ω—Å–Ω–∏–π —Å–ø–∞–ª–∞—Ö –∑–∞–ø—É—â–µ–Ω–æ!`;
    }

    // Resonance hologram
    function generateHologram() {
      if (!running) return alert("–°–ø–æ—á–∞—Ç–∫—É –∑–∞–ø—É—Å—Ç–∏ –≥–∞—Ä–º–æ–Ω—ñ—é!");
      hologramPhase = Math.PI;
      document.getElementById("output").innerHTML += `<br>üå† –†–µ–∑–æ–Ω–∞–Ω—Å–Ω–∞ –≥–æ–ª–æ–≥—Ä–∞–º–∞ –∑–∞–ø—É—â–µ–Ω–∞!`;
    }

    // Resonance vortex
    function generateVortex() {
      if (!running) return alert("–°–ø–æ—á–∞—Ç–∫—É –∑–∞–ø—É—Å—Ç–∏ –≥–∞—Ä–º–æ–Ω—ñ—é!");
      vortexPhase = Math.PI;
      document.getElementById("output").innerHTML += `<br>üåÄ –†–µ–∑–æ–Ω–∞–Ω—Å–Ω–∏–π –≤–∏—Ö–æ—Ä –∑–∞–ø—É—â–µ–Ω–æ!`;
    }

    // Resonance line pulse
    function generateLinePulse() {
      if (!running || connections.length < 1) return alert("–ü–æ—Ç—Ä—ñ–±–Ω–æ —â–æ–Ω–∞–π–º–µ–Ω—à–µ 1 –∑–≤‚Äô—è–∑–æ–∫ –¥–ª—è –ø—É–ª—å—Å–∞—Ü—ñ—ó –ª—ñ–Ω—ñ–π!");
      linePulsePhase = 0;
      document.getElementById("output").innerHTML += `<br>üåå –ü—É–ª—å—Å–∞—Ü—ñ—è –ª—ñ–Ω—ñ–π –∑–∞–ø—É—â–µ–Ω–∞!`;
    }

    // Animation editor
    function applyAnimation() {
      if (!running) return alert("–°–ø–æ—á–∞—Ç–∫—É –∑–∞–ø—É—Å—Ç–∏ –≥–∞—Ä–º–æ–Ω—ñ—é!");
      const animType = document.getElementById("animationType").value;
      const speed = parseFloat(document.getElementById("animationSpeed").value) || 1;
      if (speed < 0 || speed > 10) return alert("–®–≤–∏–¥–∫—ñ—Å—Ç—å: 0-10!");
      animations.push({ type: animType, speed });
      localStorage.setItem("resonance_animations", JSON.stringify(animations));
      document.getElementById("output").innerHTML += `<br>üé¨ –ê–Ω—ñ–º–∞—Ü—ñ—è –∑–∞—Å—Ç–æ—Å–æ–≤–∞–Ω–∞: ${animType}`;
    }

    // Pattern editor
    function applyPattern() {
      if (!running) return alert("–°–ø–æ—á–∞—Ç–∫—É –∑–∞–ø—É—Å—Ç–∏ –≥–∞—Ä–º–æ–Ω—ñ—é!");
      const patternType = document.getElementById("patternType").value;
      const amplitude = parseFloat(document.getElementById("patternAmplitude").value) || 5;
      if (amplitude < 0 || amplitude > 10) return alert("–ê–º–ø–ª—ñ—Ç—É–¥–∞: 0-10!");
      elements.forEach((el, i) => {
        if (patternType === "sine") {
          el.resonance = Math.min(100, Math.max(0, el.resonance + amplitude * Math.sin(i + pulsePhase)));
        } else if (patternType === "exp") {
          el.resonance = Math.min(100, Math.max(0, el.resonance * Math.exp(amplitude / 100)));
        } else if (patternType === "chaos") {
          el.resonance = Math.min(100, Math.max(0, el.resonance + amplitude * (Math.random() - 0.5)));
        }
      });
      displayElements(elements);
      document.getElementById("output").innerHTML += `<br>üé® –ü–∞—Ç–µ—Ä–Ω –∑–∞—Å—Ç–æ—Å–æ–≤–∞–Ω–æ: ${patternType}`;
    }

    // Resonance neural link
    function generateNeuralLink() {
      if (!running || connections.length < 1) return alert("–ü–æ—Ç—Ä—ñ–±–Ω–æ —â–æ–Ω–∞–π–º–µ–Ω—à–µ 1 –∑–≤‚Äô—è–∑–æ–∫ –¥–ª—è –Ω–µ–π—Ä–æ–Ω–Ω–æ–≥–æ –∑–≤‚Äô—è–∑–∫—É!");
      elements.forEach(el => {
        connections.forEach(conn => {
          if (conn.from === el.name) {
            const toEl = elements.find(e => e.name === conn.to);
            if (toEl) {
              const interaction = (el.resonance + toEl.resonance) * (conn.weight || 0.5) * 0.1;
              el.resonance = Math.min(100, Math.max(0, el.resonance + interaction));
              toEl.resonance = Math.min(100, Math.max(0, toEl.resonance + interaction));
            }
          }
        });
      });
      displayElements(elements);
      document.getElementById("output").innerHTML += `<br>üß† –ù–µ–π—Ä–æ–Ω–Ω–∏–π –∑–≤‚Äô—è–∑–æ–∫ —Å—Ç–≤–æ—Ä–µ–Ω–æ!`;
    }

    // Resonance singularity
    function generateSingularity() {
      if (!running || elements.length < 2) return alert("–ü–æ—Ç—Ä—ñ–±–Ω–æ —â–æ–Ω–∞–π–º–µ–Ω—à–µ 2 –µ–ª–µ–º–µ–Ω—Ç–∏ –¥–ª—è —Å–∏–Ω–≥—É–ª—è—Ä–Ω–æ—Å—Ç—ñ!");
      const singularity = {
        type: "singularity",
        name: `Singularity_${new Date().toISOString()}`,
        elements: elements.slice(0, 2),
        resonance: elements.slice(0, 2).reduce((sum, el) => sum + el.resonance, 0) * 1.5,
        timestamp: new Date().toISOString()
      };
      elements = [singularity, ...elements.slice(2)];
      displayElements(elements);
      document.getElementById("output").innerHTML += `<br>üåë –°–∏–Ω–≥—É–ª—è—Ä–Ω—ñ—Å—Ç—å —Å—Ç–≤–æ—Ä–µ–Ω–æ: ${singularity.name}`;
    }

    // Resonance fractal
    function generateFractal() {
      if (!running || elements.length < 1) return alert("–ü–æ—Ç—Ä—ñ–±–Ω–æ —â–æ–Ω–∞–π–º–µ–Ω—à–µ 1 –µ–ª–µ–º–µ–Ω—Ç –¥–ª—è —Ñ—Ä–∞–∫—Ç–∞–ª—É!");
      const fractal = {
        type: "fractal",
        name: `Fractal_${new Date().toISOString()}`,
        subElements: elements.map(el => ({
          ...el,
          resonance: el.resonance * 1.2,
          subElements: [{ ...el, resonance: el.resonance * 1.2 }]
        })),
        resonance: elements.reduce((sum, el) => sum + el.resonance, 0) * 1.2,
        timestamp: new Date().toISOString()
      };
      elements = [fractal, ...elements];
      displayElements(elements);
      document.getElementById("output").innerHTML += `<br>üåê –§—Ä–∞–∫—Ç–∞–ª —Å—Ç–≤–æ—Ä–µ–Ω–æ: ${fractal.name}`;
    }

    // Element editor
    function addElement() {
      const name = document.getElementById("elementName").value;
      const type = document.getElementById("elementType").value;
      if (!name) return alert("–í–≤–µ–¥–∏ –Ω–∞–∑–≤—É –µ–ª–µ–º–µ–Ω—Ç–∞!");
      const newElement = { type, name, resonance: 60, timestamp: new Date().toISOString() };
      if (type === "glyph") newElement.glyph = [name];
      else if (type === "network") newElement.nodes = [{ resonance: 60 }];
      else if (type === "rule") newElement.ruleType = "custom";
      else if (type === "cosmos") newElement.singularities = [{ elements: [{ resonance: 60 }] }];
      elements.push(newElement);
      displayElements(elements);
      updateNodeEditor();
      document.getElementById("output").innerHTML += `<br>‚ûï –ï–ª–µ–º–µ–Ω—Ç –¥–æ–¥–∞–Ω–æ: ${name}`;
    }

    // Post history
    function showPostHistory() {
      let output = "<br>üìú –Ü—Å—Ç–æ—Ä—ñ—è –ø–æ—Å—Ç—ñ–≤:<br>";
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key.startsWith("fediverse_post_")) {
          const post = JSON.parse(localStorage.getItem(key));
          output += `<div>üïí ${post.timestamp}: ${post.status}<br>`;
          if (post.image) output += `<img src="${post.image}" style="max-width: 200px;"><br>`;
          output += `–†–µ–∞–∫—Ü—ñ—ó: ${Math.floor(Math.random() * 20)} –ª–∞–π–∫—ñ–≤, ${Math.floor(Math.random() * 10)} —Ä–µ–ø–æ—Å—Ç—ñ–≤, ${Math.floor(Math.random() * 5)} –∫–æ–º–µ–Ω—Ç–∞—Ä—ñ–≤</div>`;
        }
      }
      document.getElementById("output").innerHTML += output;
    }

    async function verifySignature(data, signature) {
      return btoa(String.fromCharCode(...new TextEncoder().encode(data))).slice(0, 32) === signature;
    }

    async function signData(data) {
      return btoa(String.fromCharCode(...new TextEncoder().encode(data))).slice(0, 32);
    }

    async function postToFediverse() {
      if (!moments.length) return alert("–ù–µ–º–∞—î –º–æ–º–µ–Ω—Ç—ñ–≤ –¥–ª—è –ø—É–±–ª—ñ–∫–∞—Ü—ñ—ó!");
      const lastMoment = moments[moments.length - 1];
      const instance = document.getElementById("fediverse-instance").value;
      const customPost = document.getElementById("fediverse-post").value;
      const schedule = document.getElementById("fediverse-schedule").value;
      const message = customPost || `üåå –ù–æ–≤–∏–π –º–æ–º–µ–Ω—Ç —É Resonance Hub: ${lastMoment.elements.length} –µ–ª–µ–º–µ–Ω—Ç—ñ–≤ —Ä–µ–∑–æ–Ω—É—é—Ç—å –Ω–∞ ${lastMoment.elements.reduce((sum, el) => sum + el.resonance, 0).toFixed(1)}%!\n#Resonance #Spark #oQs`;
      const postId = `post_${new Date().toISOString()}`;
      const image = vizCanvas.toDataURL("image/png");
      document.getElementById("fediverse-preview").innerHTML = `<div>–ü–æ–ø–µ—Ä–µ–¥–Ω—ñ–π –ø–µ—Ä–µ–≥–ª—è–¥: ${message}<br><img src="${image}" style="max-width: 200px;"><br>–†–µ–∞–∫—Ü—ñ—ó (–∑–∞–≥–ª—É—à–∫–∞): ${Math.floor(Math.random() * 20)} –ª–∞–π–∫—ñ–≤, ${Math.floor(Math.random() * 10)} —Ä–µ–ø–æ—Å—Ç—ñ–≤, ${Math.floor(Math.random() * 5)} –∫–æ–º–µ–Ω—Ç–∞—Ä—ñ–≤</div>`;
      try {
        const postData = {
          id: postId,
          status: message,
          visibility: "public",
          content_type: "text/plain",
          image: image,
          scheduled_at: schedule || null,
          timestamp: new Date().toISOString()
        };
        localStorage.setItem(`fediverse_post_${postId}`, JSON.stringify(postData));
        alert(`–ü—É–±–ª—ñ–∫–∞—Ü—ñ—è –≤ Fediverse (${instance}): ${message}${schedule ? ` (–ó–∞–ø–ª–∞–Ω–æ–≤–∞–Ω–æ –Ω–∞ ${schedule})` : ""}`);
      } catch (e) {
        alert("–ü–æ–º–∏–ª–∫–∞ –ø—É–±–ª—ñ–∫–∞—Ü—ñ—ó –≤ Fediverse: " + e.message);
      }
    }

    let blobCache = null;
    function saveHarmony() {
      if (!blobCache) blobCache = new Blob([JSON.stringify({ elements, moments, connections, animations, timeline: timelineItems }, null, 2)], { type: "application/json" });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blobCache);
      a.download = "resonance-hub.json";
      a.click();
    }

    function savePng() {
      const a = document.createElement("a");
      a.href = vizCanvas.toDataURL("image/png");
      a.download = "resonance-hub.png";
      a.click();
    }
  </script>
</body>
</html>
