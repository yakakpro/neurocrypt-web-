<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>üß† –ù–µ–π—Ä–æ—à–∏—Ñ—Ä–∞—Ç–æ—Ä ‚àû</title>
  <style>
    body { font-family: monospace; background: #0e0e0e; color: #00ffcc; padding: 2rem; }
    input, textarea, button, select { background: #111; color: #00ffcc; border: 1px solid #00ffcc; padding: 0.5rem; margin: 0.5rem 0; width: 100%; }
    button { cursor: pointer; }
    .section { border: 1px solid #333; padding: 1rem; margin-bottom: 2rem; }
    .hidden { display: none; }
    #dropzone { border: 2px dashed #00ffcc; padding: 1rem; text-align: center; margin-bottom: 1rem; }
    canvas { max-width: 100%; margin-top: 1rem; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.1/build/qrcode.min.js"></script>
</head>
<body>
  <h1>üß† –ù–µ–π—Ä–æ—à–∏—Ñ—Ä–∞—Ç–æ—Ä ‚àû</h1>

  <div class="section">
    <h2>üîê –†–µ–∂–∏–º</h2>
    <select id="modeSelect" onchange="toggleMode()">
      <option value="simple">–ë–∞–∑–æ–≤–∏–π</option>
      <option value="dual">–ó –ø—Ä–∏–∫—Ä–∏—Ç—Ç—è–º</option>
      <option value="multi">–ë–∞–≥–∞—Ç–æ—Ä—ñ–≤–Ω–µ–≤–∏–π —Å–µ–π—Ñ</option>
    </select>
  </div>

  <div id="simpleSection" class="section">
    <h2>üîí –ë–∞–∑–æ–≤–µ —à–∏—Ñ—Ä—É–≤–∞–Ω–Ω—è</h2>
    <input type="text" id="phrase" placeholder="üîë –ù–µ–π—Ä–æ—Ñ—Ä–∞–∑–∞" />
    <input type="text" id="emo" placeholder="üé® –ï–º–æ-–∫–æ–¥ (–Ω–∞–ø—Ä. üî•üíßüåï)" />
    <textarea id="message" rows="4" placeholder="‚úç –ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è"></textarea>
    <button onclick="encryptSimple()">–ó–∞—à–∏—Ñ—Ä—É–≤–∞—Ç–∏</button>
    <textarea id="encrypted" rows="3" readonly placeholder="üîê –ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–æ —Ç—É—Ç"></textarea>
  </div>

  <div id="dualSection" class="section hidden">
    <h2>üé≠ –ó –ø—Ä–∏–∫—Ä–∏—Ç—Ç—è–º</h2>
    <input type="text" id="realPhrase" placeholder="üîë –°–ø—Ä–∞–≤–∂–Ω—è —Ñ—Ä–∞–∑–∞" />
    <input type="text" id="realEmo" placeholder="üé® –ï–º–æ-–∫–æ–¥" />
    <textarea id="realMessage" rows="3"></textarea>
    <input type="text" id="fakePhrase" placeholder="üîë –§—Ä–∞–∑–∞ –ø—Ä–∏–∫—Ä–∏—Ç—Ç—è" />
    <input type="text" id="fakeEmo" placeholder="üé® –ï–º–æ-–∫–æ–¥" />
    <textarea id="fakeMessage" rows="3"></textarea>
    <button onclick="encryptDual()">–ó–∞—à–∏—Ñ—Ä—É–≤–∞—Ç–∏ –æ–±–∏–¥–≤–∞</button>
    <button onclick="saveDualVault()">üíæ –ó–±–µ—Ä–µ–≥—Ç–∏ Vault</button>
    <textarea id="dualVault" rows="5" readonly placeholder="üîê Vault JSON"></textarea>
  </div>

  <div id="multiSection" class="section hidden">
    <h2>üåÄ –ë–∞–≥–∞—Ç–æ—Ä—ñ–≤–Ω–µ–≤–∏–π —Å–µ–π—Ñ</h2>
    <div id="layerContainer"></div>
    <button onclick="addLayer()">‚ûï –î–æ–¥–∞—Ç–∏ —à–∞—Ä</button>
    <button onclick="encryptMulti()">üîê –ó–∞—à–∏—Ñ—Ä—É–≤–∞—Ç–∏ –≤—Å—ñ —à–∞—Ä–∏</button>
    <button onclick="saveMultiVault()">üíæ –ó–±–µ—Ä–µ–≥—Ç–∏ Vault</button>
    <textarea id="multiVault" rows="6" readonly placeholder="üì¶ JSON-—Å–µ–π—Ñ"></textarea>
  </div>

  <div class="section">
    <h2>üìÇ –ó–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ Vault</h2>
    <input type="file" id="vaultLoader" onchange="loadVaultFile(event)" />
    <div id="dropzone" ondrop="dropVault(event)" ondragover="event.preventDefault()">
      –ü–µ—Ä–µ—Ç—è–≥–Ω–∏ —Å—é–¥–∏ —Å–≤—ñ–π .vault.json —Ñ–∞–π–ª üßä
    </div>
    <label><input type="checkbox" id="autoDelete" /> üî• –í–∏–¥–∞–ª–∏—Ç–∏ –ø—ñ—Å–ª—è —Ä–æ–∑—à–∏—Ñ—Ä—É–≤–∞–Ω–Ω—è</label>
    <h2>üîì –†–æ–∑—à–∏—Ñ—Ä—É–≤–∞—Ç–∏</h2>
    <textarea id="inputVault" rows="5" placeholder="üì• –í—Å—Ç–∞–≤ JSON-—Å–µ–π—Ñ"></textarea>
    <button onclick="decryptVault()">–†–æ–∑—à–∏—Ñ—Ä—É–≤–∞—Ç–∏</button>
    <div id="decryptionResult"></div>
    <h3>üì∏ –°—Ç–≤–æ—Ä–∏—Ç–∏ QR –¥–ª—è Vault</h3>
    <button onclick="generateQR('dark')">QR üåí (—Ç–µ–º–Ω–∏–π)</button>
    <button onclick="generateQR('light')">QR üåï (—Å–≤—ñ—Ç–ª–∏–π)</button>
    <button onclick="saveQRAsPNG()">üíæ –ó–±–µ—Ä–µ–≥—Ç–∏ QR</button>
    <canvas id="qrcanvas"></canvas>
  </div>

  <script>
    const toggleMode = () => {
      document.getElementById("simpleSection").classList.add("hidden");
      document.getElementById("dualSection").classList.add("hidden");
      document.getElementById("multiSection").classList.add("hidden");
      const mode = document.getElementById("modeSelect").value;
      if (mode === "simple") document.getElementById("simpleSection").classList.remove("hidden");
      if (mode === "dual") document.getElementById("dualSection").classList.remove("hidden");
      if (mode === "multi") document.getElementById("multiSection").classList.remove("hidden");
    };

    const getKey = async (phrase, emo) => {
      const combined = phrase + '::' + emo;
      const msgUint8 = new TextEncoder().encode(combined);
      const hashBuffer = await crypto.subtle.digest('SHA-256', msgUint8);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      const base64 = btoa(String.fromCharCode(...hashArray)).replace(/\+/g, '-').replace(/\//g, '_');
      return base64.substring(0, 32).padEnd(32, '=');
    };

    const aesEncrypt = async (text, phrase, emo) => {
      const key = await getKey(phrase, emo);
      const rawKey = new TextEncoder().encode(key).slice(0, 16);
      const iv = crypto.getRandomValues(new Uint8Array(16));
      const cryptoKey = await crypto.subtle.importKey("raw", rawKey, "AES-CBC", false, ["encrypt"]);
      const encrypted = await crypto.subtle.encrypt({ name: "AES-CBC", iv }, cryptoKey, new TextEncoder().encode(text));
      return btoa(String.fromCharCode(...iv, ...new Uint8Array(encrypted)));
    };

    const aesDecrypt = async (data, phrase, emo) => {
      try {
        const key = await getKey(phrase, emo);
        const rawKey = new TextEncoder().encode(key).slice(0, 16);
        const bytes = Uint8Array.from(atob(data), c => c.charCodeAt(0));
        const iv = bytes.slice(0, 16);
        const encrypted = bytes.slice(16);
        const cryptoKey = await crypto.subtle.importKey("raw", rawKey, "AES-CBC", false, ["decrypt"]);
        const decrypted = await crypto.subtle.decrypt({ name: "AES-CBC", iv }, cryptoKey, encrypted);
        return new TextDecoder().decode(decrypted);
      } catch {
        return "‚õî –ù–µ–≤—ñ—Ä–Ω–∏–π –∫–ª—é—á –∞–±–æ —à–∏—Ñ—Ä.";
      }
    };

    const encryptSimple = async () => {
      const phrase = document.getElementById("phrase").value;
      const emo = document.getElementById("emo").value;
      const msg = document.getElementById("message").value;
      const encrypted = await aesEncrypt(msg, phrase, emo);
      document.getElementById("encrypted").value = encrypted;
    };

    const encryptDual = async () => {
      const real = await aesEncrypt(document.getElementById("realMessage").value, document.getElementById("realPhrase").value, document.getElementById("realEmo").value);
      const fake = await aesEncrypt(document.getElementById("fakeMessage").value, document.getElementById("fakePhrase").value, document.getElementById("fakeEmo").value);
      const vault = { mode: "dual", real, fake };
      document.getElementById("dualVault").value = JSON.stringify(vault, null, 2);
    };

    const saveDualVault = () => {
      const text = document.getElementById("dualVault").value;
      downloadFile(text, "vault_dual.json");
    };

    const addLayer = () => {
      const container = document.getElementById("layerContainer");
      const div = document.createElement("div");
      div.innerHTML = `
        <input placeholder="üîñ –ù–∞–∑–≤–∞" />
        <input placeholder="üîë –§—Ä–∞–∑–∞" />
        <input placeholder="üé® –ï–º–æ-–∫–æ–¥" />
        <textarea placeholder="‚úç –ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è" rows="3"></textarea>
        <hr />
      `;
      container.appendChild(div);
    };

    const encryptMulti = async () => {
      const layers = document.querySelectorAll("#layerContainer > div");
      const result = [];
      for (const layer of layers) {
        const [label, phrase, emo, msg] = layer.querySelectorAll("input, textarea");
        const token = await aesEncrypt(msg.value, phrase.value, emo.value);
        result.push({ label: label.value, token });
      }
      document.getElementById("multiVault").value = JSON.stringify({ mode: "multi", layers: result }, null, 2);
    };

    const saveMultiVault = () => {
      const text = document.getElementById("multiVault").value;
      downloadFile(text, "vault_multi.json");
    };

    const decryptVault = async () => {
      const json = document.getElementById("inputVault").value;
      const vault = JSON.parse(json);
      let output = "";

      if (vault.mode === "dual") {
        const phrase = prompt("üîë –í–≤–µ–¥–∏ —Ñ—Ä–∞–∑—É:");
        const emo = prompt("üé® –ï–º–æ-–∫–æ–¥:");
        let msg = await aesDecrypt(vault.real, phrase, emo);
        if (msg.startsWith("‚õî")) msg = await aesDecrypt(vault.fake, phrase, emo);
        output = msg;
      } else if (vault.mode === "multi") {
        for (const layer of vault.layers) {
          output += `\nüîí ${layer.label}\n`;
          const phrase = prompt(`–§—Ä–∞–∑–∞ –¥–ª—è ${layer.label}`);
          const emo = prompt(`–ï–º–æ-–∫–æ–¥ –¥–ª—è ${layer.label}`);
          output += await aesDecrypt(layer.token, phrase, emo) + "\n";
        }
      } else {
        const phrase = prompt("üîë –§—Ä–∞–∑–∞:");
        const emo = prompt("üé® –ï–º–æ-–∫–æ–¥:");
        output = await aesDecrypt(vault.real || json, phrase, emo);
      }

      document.getElementById("decryptionResult").innerText = output;
      if (document.getElementById("autoDelete").checked) {
        document.getElementById("inputVault").value = "";
        document.getElementById("vaultLoader").value = "";
      }
    };

    const downloadFile = (text, filename) => {
      const blob = new Blob([text], { type: "application/json" });
      const link = document.createElement("a");
      link.href = URL.createObjectURL(blob);
      link.download = filename;
      link.click();
    };

    const loadVaultFile = (event) => {
      const file = event.target.files[0];
      const reader = new FileReader();
      reader.onload = (e) => {
        document.getElementById("inputVault").value = e.target.result;
      };
      if (file) reader.readAsText(file);
    };

    const dropVault = (e) => {
      e.preventDefault();
      const file = e.dataTransfer.files[0];
      if (file && file.type.includes("json")) {
        const reader = new FileReader();
        reader.onload = (ev) => {
          document.getElementById("inputVault").value = ev.target.result;
        };
        reader.readAsText(file);
      }
    };

    const generateQR = (style) => {
      const data = document.getElementById("inputVault").value;
      if (!data) return alert("üì≠ –°–ø–æ—á–∞—Ç–∫—É –≤—Å—Ç–∞–≤ JSON Vault!");
      let parsed;
      try {
        parsed = JSON.stringify(JSON.parse(data));
      } catch {
        return alert("‚ö†Ô∏è –ù–µ–≤—ñ—Ä–Ω–∏–π JSON");
      }
      const color = style === 'light' ? { dark: "#000000", light: "#ffffff" } : { dark: "#00ffcc", light: "#0e0e0e" };
      QRCode.toCanvas(document.getElementById("qrcanvas"), parsed, { width: 256, color });
    };

    const saveQRAsPNG = () => {
      const canvas = document.getElementById("qrcanvas");
      const link = document.createElement("a");
      link.download = "vault_qr.png";
      link.href = canvas.toDataURL("image/png");
      link.click();
    };
  </script>
</body>
</html>
